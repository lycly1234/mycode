# 线程安全性
## 原子性
### 竞态条件
1. 常见的为检查后执行-- 校验一个状态，再进行业务操作，但这个状态在并发的情况下是一个过时的状态
   - 校验这个状态并没有意义，甚至可能产生错误的数据
   - 基于一种可能会失效的观察结果做出判断。
   - 例子：LazyInitRace.java
   - 竞态条件为判断语句，可能会因为并发达到竞态条件，返回了不同地址实例
2. 读取-修改-写入 可能a线程修改的时候，b线程读取到旧值，判断需要修改成c值，导致程序错误
   - 状态机中，基于上一个状态去修改，可能会导致错误的状态产生
### 复合操作
将竞态条件的变成原子操作
无状态类变成有状态，但状态被线程安全的类管理，这个类还是线程安全的。

## 定义
线程安全性：多个线程之间的操作无论采用何种执行时序或者交替方式，都要保证不变性条件不被破坏。
要保持状态一致性：单个原子操作更新所有相关的状态变量

### 内置锁
synchornized 关键字，使用Java对象作为一个实现同步的锁  ---内置锁
互斥锁：只有一个线程能拿到锁，具有排他性
同步代码块，a线程进入同步代码块后获得锁，退出同步代码块后失去锁，其他线程必须等待或阻塞，等待获取到这个锁
```
synchronized(lock){
    //访问修改保护的状态
        }
```
**缺点：** 并发性能非常差，其他线程都一直等待获取锁

重入：某个线程获得自己曾经持有的锁
monitor监视器的数值+1，退出时-1


### 用锁来保护状态
